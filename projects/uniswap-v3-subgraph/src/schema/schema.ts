
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { String, Int, BigInt, Float, ID, Bytes, Timestamp, Boolean, Int8 } from '@sentio/sdk/store'
import { Entity, Required, One, Many, Column, ListColumn, AbstractEntity, getStore, UpdateValues } from '@sentio/sdk/store'
import { BigDecimal } from '@sentio/bigdecimal'
import { DatabaseSchema } from '@sentio/sdk'







interface FactoryConstructorInput {
  id: ID;
  poolCount: BigInt;
  txCount: BigInt;
  totalVolumeUSD: BigDecimal;
  totalVolumeETH: BigDecimal;
  totalFeesUSD: BigDecimal;
  totalFeesETH: BigDecimal;
  untrackedVolumeUSD: BigDecimal;
  totalValueLockedUSD: BigDecimal;
  totalValueLockedETH: BigDecimal;
  totalValueLockedUSDUntracked: BigDecimal;
  totalValueLockedETHUntracked: BigDecimal;
  owner: ID;
}
@Entity("Factory")
export class Factory extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("BigInt")
	poolCount: BigInt

	@Required
	@Column("BigInt")
	txCount: BigInt

	@Required
	@Column("BigDecimal")
	totalVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalVolumeETH: BigDecimal

	@Required
	@Column("BigDecimal")
	totalFeesUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalFeesETH: BigDecimal

	@Required
	@Column("BigDecimal")
	untrackedVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedETH: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedUSDUntracked: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedETHUntracked: BigDecimal

	@Required
	@Column("ID")
	owner: ID
  constructor(data: FactoryConstructorInput) {super()}
  
  
  static update(values: UpdateValues<FactoryConstructorInput>): Promise<void> {
    return getStore().update(Factory, values)
  }
}


interface BundleConstructorInput {
  id: ID;
  ethPriceUSD: BigDecimal;
}
@Entity("Bundle")
export class Bundle extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("BigDecimal")
	ethPriceUSD: BigDecimal
  constructor(data: BundleConstructorInput) {super()}
  
  
  static update(values: UpdateValues<BundleConstructorInput>): Promise<void> {
    return getStore().update(Bundle, values)
  }
}


interface TokenConstructorInput {
  id: Bytes;
  symbol: String;
  name: String;
  decimals: BigInt;
  totalSupply: BigInt;
  volume: BigDecimal;
  volumeUSD: BigDecimal;
  untrackedVolumeUSD: BigDecimal;
  feesUSD: BigDecimal;
  txCount: BigInt;
  poolCount: BigInt;
  totalValueLocked: BigDecimal;
  totalValueLockedUSD: BigDecimal;
  totalValueLockedUSDUntracked: BigDecimal;
  derivedETH: BigDecimal;
  whitelistPoolsIDs?: Array<ID>;
}
@Entity("Token")
export class Token extends AbstractEntity  {

	@Required
	@Column("Bytes")
	id: Bytes

	@Required
	@Column("String")
	symbol: String

	@Required
	@Column("String")
	name: String

	@Required
	@Column("BigInt")
	decimals: BigInt

	@Required
	@Column("BigInt")
	totalSupply: BigInt

	@Required
	@Column("BigDecimal")
	volume: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	untrackedVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	feesUSD: BigDecimal

	@Required
	@Column("BigInt")
	txCount: BigInt

	@Required
	@Column("BigInt")
	poolCount: BigInt

	@Required
	@Column("BigDecimal")
	totalValueLocked: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedUSDUntracked: BigDecimal

	@Required
	@Column("BigDecimal")
	derivedETH: BigDecimal

	@Required
	@Many("Pool!")
	_whitelistPools: Promise<Array<Pool>>

	whitelistPoolsIDs: Array<ID | undefined>
  constructor(data: TokenConstructorInput) {super()}
  
  whitelistPools(): Promise<Array<Pool>> {
    return this._whitelistPools
  }

  setWhitelistPools(whitelistPools: Array<Pool>) {
    if (whitelistPools) this.whitelistPoolsIDs = whitelistPools.map((e) => e.id)
  }

  tokenDayData(): Promise<Array<TokenDayData>> {
    return this.store.list(TokenDayData, [{field: 'token', op: '=', value: this.id}])
  }
  
  static update(values: UpdateValues<TokenConstructorInput>): Promise<void> {
    return getStore().update(Token, values)
  }
}


interface PoolConstructorInput {
  id: Bytes;
  createdAtTimestamp: BigInt;
  createdAtBlockNumber: BigInt;
  token0ID?: ID;
  token1ID?: ID;
  feeTier: BigInt;
  liquidity: BigInt;
  sqrtPrice: BigInt;
  token0Price: BigDecimal;
  token1Price: BigDecimal;
  tick?: BigInt;
  observationIndex: BigInt;
  volumeToken0: BigDecimal;
  volumeToken1: BigDecimal;
  volumeUSD: BigDecimal;
  untrackedVolumeUSD: BigDecimal;
  feesUSD: BigDecimal;
  txCount: BigInt;
  collectedFeesToken0: BigDecimal;
  collectedFeesToken1: BigDecimal;
  collectedFeesUSD: BigDecimal;
  totalValueLockedToken0: BigDecimal;
  totalValueLockedToken1: BigDecimal;
  totalValueLockedETH: BigDecimal;
  totalValueLockedUSD: BigDecimal;
  totalValueLockedUSDUntracked: BigDecimal;
  liquidityProviderCount: BigInt;
}
@Entity("Pool")
export class Pool extends AbstractEntity  {

	@Required
	@Column("Bytes")
	id: Bytes

	@Required
	@Column("BigInt")
	createdAtTimestamp: BigInt

	@Required
	@Column("BigInt")
	createdAtBlockNumber: BigInt

	@Required
	@One("Token")
	_token0: Promise<Token>

	token0ID: ID

	@Required
	@One("Token")
	_token1: Promise<Token>

	token1ID: ID

	@Required
	@Column("BigInt")
	feeTier: BigInt

	@Required
	@Column("BigInt")
	liquidity: BigInt

	@Required
	@Column("BigInt")
	sqrtPrice: BigInt

	@Required
	@Column("BigDecimal")
	token0Price: BigDecimal

	@Required
	@Column("BigDecimal")
	token1Price: BigDecimal

	@Column("BigInt")
	tick?: BigInt

	@Required
	@Column("BigInt")
	observationIndex: BigInt

	@Required
	@Column("BigDecimal")
	volumeToken0: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeToken1: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	untrackedVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	feesUSD: BigDecimal

	@Required
	@Column("BigInt")
	txCount: BigInt

	@Required
	@Column("BigDecimal")
	collectedFeesToken0: BigDecimal

	@Required
	@Column("BigDecimal")
	collectedFeesToken1: BigDecimal

	@Required
	@Column("BigDecimal")
	collectedFeesUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedToken0: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedToken1: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedETH: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedUSDUntracked: BigDecimal

	@Required
	@Column("BigInt")
	liquidityProviderCount: BigInt
  constructor(data: PoolConstructorInput) {super()}
  
  token0(): Promise<Token> {
    return this._token0
  }

  setToken0(token0: Token) {
    if (token0) this.token0ID = token0.id
  }

  token1(): Promise<Token> {
    return this._token1
  }

  setToken1(token1: Token) {
    if (token1) this.token1ID = token1.id
  }

  poolHourData(): Promise<Array<PoolHourData>> {
    return this.store.list(PoolHourData, [{field: 'pool', op: '=', value: this.id}])
  }

  poolDayData(): Promise<Array<PoolDayData>> {
    return this.store.list(PoolDayData, [{field: 'pool', op: '=', value: this.id}])
  }

  mints(): Promise<Array<Mint>> {
    return this.store.list(Mint, [{field: 'pool', op: '=', value: this.id}])
  }

  burns(): Promise<Array<Burn>> {
    return this.store.list(Burn, [{field: 'pool', op: '=', value: this.id}])
  }

  swaps(): Promise<Array<Swap>> {
    return this.store.list(Swap, [{field: 'pool', op: '=', value: this.id}])
  }

  collects(): Promise<Array<Collect>> {
    return this.store.list(Collect, [{field: 'pool', op: '=', value: this.id}])
  }

  ticks(): Promise<Array<Tick>> {
    return this.store.list(Tick, [{field: 'pool', op: '=', value: this.id}])
  }
  
  static update(values: UpdateValues<PoolConstructorInput>): Promise<void> {
    return getStore().update(Pool, values)
  }
}


interface TickConstructorInput {
  id: ID;
  poolAddress: Bytes;
  tickIdx: BigInt;
  poolID?: ID;
  liquidityGross: BigInt;
  liquidityNet: BigInt;
  price0: BigDecimal;
  price1: BigDecimal;
  createdAtTimestamp: BigInt;
  createdAtBlockNumber: BigInt;
}
@Entity("Tick")
export class Tick extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Bytes")
	poolAddress: Bytes

	@Required
	@Column("BigInt")
	tickIdx: BigInt

	@Required
	@One("Pool")
	_pool: Promise<Pool>

	poolID: ID

	@Required
	@Column("BigInt")
	liquidityGross: BigInt

	@Required
	@Column("BigInt")
	liquidityNet: BigInt

	@Required
	@Column("BigDecimal")
	price0: BigDecimal

	@Required
	@Column("BigDecimal")
	price1: BigDecimal

	@Required
	@Column("BigInt")
	createdAtTimestamp: BigInt

	@Required
	@Column("BigInt")
	createdAtBlockNumber: BigInt
  constructor(data: TickConstructorInput) {super()}
  
  pool(): Promise<Pool> {
    return this._pool
  }

  setPool(pool: Pool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<TickConstructorInput>): Promise<void> {
    return getStore().update(Tick, values)
  }
}


interface TransactionConstructorInput {
  id: ID;
  blockNumber: BigInt;
  timestamp: BigInt;
  gasUsed: BigInt;
  gasPrice: BigInt;
}
@Entity("Transaction")
export class Transaction extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@Column("BigInt")
	gasUsed: BigInt

	@Required
	@Column("BigInt")
	gasPrice: BigInt
  constructor(data: TransactionConstructorInput) {super()}
  
  mints(): Promise<Array<Mint | undefined>> {
    return this.store.list(Mint, [{field: 'transaction', op: '=', value: this.id}])
  }

  burns(): Promise<Array<Burn | undefined>> {
    return this.store.list(Burn, [{field: 'transaction', op: '=', value: this.id}])
  }

  swaps(): Promise<Array<Swap | undefined>> {
    return this.store.list(Swap, [{field: 'transaction', op: '=', value: this.id}])
  }

  flashed(): Promise<Array<Flash | undefined>> {
    return this.store.list(Flash, [{field: 'transaction', op: '=', value: this.id}])
  }

  collects(): Promise<Array<Collect | undefined>> {
    return this.store.list(Collect, [{field: 'transaction', op: '=', value: this.id}])
  }
  
  static update(values: UpdateValues<TransactionConstructorInput>): Promise<void> {
    return getStore().update(Transaction, values)
  }
}


interface MintConstructorInput {
  id: ID;
  transactionID?: ID;
  timestamp: BigInt;
  poolID?: ID;
  token0ID?: ID;
  token1ID?: ID;
  owner: Bytes;
  sender?: Bytes;
  origin: Bytes;
  amount: BigInt;
  amount0: BigDecimal;
  amount1: BigDecimal;
  amountUSD?: BigDecimal;
  tickLower: BigInt;
  tickUpper: BigInt;
  logIndex?: BigInt;
}
@Entity("Mint")
export class Mint extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("Transaction")
	_transaction: Promise<Transaction>

	transactionID: ID

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@One("Pool")
	_pool: Promise<Pool>

	poolID: ID

	@Required
	@One("Token")
	_token0: Promise<Token>

	token0ID: ID

	@Required
	@One("Token")
	_token1: Promise<Token>

	token1ID: ID

	@Required
	@Column("Bytes")
	owner: Bytes

	@Column("Bytes")
	sender?: Bytes

	@Required
	@Column("Bytes")
	origin: Bytes

	@Required
	@Column("BigInt")
	amount: BigInt

	@Required
	@Column("BigDecimal")
	amount0: BigDecimal

	@Required
	@Column("BigDecimal")
	amount1: BigDecimal

	@Column("BigDecimal")
	amountUSD?: BigDecimal

	@Required
	@Column("BigInt")
	tickLower: BigInt

	@Required
	@Column("BigInt")
	tickUpper: BigInt

	@Column("BigInt")
	logIndex?: BigInt
  constructor(data: MintConstructorInput) {super()}
  
  transaction(): Promise<Transaction> {
    return this._transaction
  }

  setTransaction(transaction: Transaction) {
    if (transaction) this.transactionID = transaction.id
  }

  pool(): Promise<Pool> {
    return this._pool
  }

  setPool(pool: Pool) {
    if (pool) this.poolID = pool.id
  }

  token0(): Promise<Token> {
    return this._token0
  }

  setToken0(token0: Token) {
    if (token0) this.token0ID = token0.id
  }

  token1(): Promise<Token> {
    return this._token1
  }

  setToken1(token1: Token) {
    if (token1) this.token1ID = token1.id
  }
  
  static update(values: UpdateValues<MintConstructorInput>): Promise<void> {
    return getStore().update(Mint, values)
  }
}


interface BurnConstructorInput {
  id: ID;
  transactionID?: ID;
  poolID?: ID;
  token0ID?: ID;
  token1ID?: ID;
  timestamp: BigInt;
  owner?: Bytes;
  origin: Bytes;
  amount: BigInt;
  amount0: BigDecimal;
  amount1: BigDecimal;
  amountUSD?: BigDecimal;
  tickLower: BigInt;
  tickUpper: BigInt;
  logIndex?: BigInt;
}
@Entity("Burn")
export class Burn extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("Transaction")
	_transaction: Promise<Transaction>

	transactionID: ID

	@Required
	@One("Pool")
	_pool: Promise<Pool>

	poolID: ID

	@Required
	@One("Token")
	_token0: Promise<Token>

	token0ID: ID

	@Required
	@One("Token")
	_token1: Promise<Token>

	token1ID: ID

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Column("Bytes")
	owner?: Bytes

	@Required
	@Column("Bytes")
	origin: Bytes

	@Required
	@Column("BigInt")
	amount: BigInt

	@Required
	@Column("BigDecimal")
	amount0: BigDecimal

	@Required
	@Column("BigDecimal")
	amount1: BigDecimal

	@Column("BigDecimal")
	amountUSD?: BigDecimal

	@Required
	@Column("BigInt")
	tickLower: BigInt

	@Required
	@Column("BigInt")
	tickUpper: BigInt

	@Column("BigInt")
	logIndex?: BigInt
  constructor(data: BurnConstructorInput) {super()}
  
  transaction(): Promise<Transaction> {
    return this._transaction
  }

  setTransaction(transaction: Transaction) {
    if (transaction) this.transactionID = transaction.id
  }

  pool(): Promise<Pool> {
    return this._pool
  }

  setPool(pool: Pool) {
    if (pool) this.poolID = pool.id
  }

  token0(): Promise<Token> {
    return this._token0
  }

  setToken0(token0: Token) {
    if (token0) this.token0ID = token0.id
  }

  token1(): Promise<Token> {
    return this._token1
  }

  setToken1(token1: Token) {
    if (token1) this.token1ID = token1.id
  }
  
  static update(values: UpdateValues<BurnConstructorInput>): Promise<void> {
    return getStore().update(Burn, values)
  }
}


interface SwapConstructorInput {
  id: ID;
  transactionID?: ID;
  timestamp: BigInt;
  poolID?: ID;
  token0ID?: ID;
  token1ID?: ID;
  sender: Bytes;
  recipient: Bytes;
  origin: Bytes;
  amount0: BigDecimal;
  amount1: BigDecimal;
  amountUSD: BigDecimal;
  sqrtPriceX96: BigInt;
  tick: BigInt;
  logIndex?: BigInt;
}
@Entity("Swap")
export class Swap extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("Transaction")
	_transaction: Promise<Transaction>

	transactionID: ID

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@One("Pool")
	_pool: Promise<Pool>

	poolID: ID

	@Required
	@One("Token")
	_token0: Promise<Token>

	token0ID: ID

	@Required
	@One("Token")
	_token1: Promise<Token>

	token1ID: ID

	@Required
	@Column("Bytes")
	sender: Bytes

	@Required
	@Column("Bytes")
	recipient: Bytes

	@Required
	@Column("Bytes")
	origin: Bytes

	@Required
	@Column("BigDecimal")
	amount0: BigDecimal

	@Required
	@Column("BigDecimal")
	amount1: BigDecimal

	@Required
	@Column("BigDecimal")
	amountUSD: BigDecimal

	@Required
	@Column("BigInt")
	sqrtPriceX96: BigInt

	@Required
	@Column("BigInt")
	tick: BigInt

	@Column("BigInt")
	logIndex?: BigInt
  constructor(data: SwapConstructorInput) {super()}
  
  transaction(): Promise<Transaction> {
    return this._transaction
  }

  setTransaction(transaction: Transaction) {
    if (transaction) this.transactionID = transaction.id
  }

  pool(): Promise<Pool> {
    return this._pool
  }

  setPool(pool: Pool) {
    if (pool) this.poolID = pool.id
  }

  token0(): Promise<Token> {
    return this._token0
  }

  setToken0(token0: Token) {
    if (token0) this.token0ID = token0.id
  }

  token1(): Promise<Token> {
    return this._token1
  }

  setToken1(token1: Token) {
    if (token1) this.token1ID = token1.id
  }
  
  static update(values: UpdateValues<SwapConstructorInput>): Promise<void> {
    return getStore().update(Swap, values)
  }
}


interface CollectConstructorInput {
  id: ID;
  transactionID?: ID;
  timestamp: BigInt;
  poolID?: ID;
  owner?: Bytes;
  amount0: BigDecimal;
  amount1: BigDecimal;
  amountUSD?: BigDecimal;
  tickLower: BigInt;
  tickUpper: BigInt;
  logIndex?: BigInt;
}
@Entity("Collect")
export class Collect extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("Transaction")
	_transaction: Promise<Transaction>

	transactionID: ID

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@One("Pool")
	_pool: Promise<Pool>

	poolID: ID

	@Column("Bytes")
	owner?: Bytes

	@Required
	@Column("BigDecimal")
	amount0: BigDecimal

	@Required
	@Column("BigDecimal")
	amount1: BigDecimal

	@Column("BigDecimal")
	amountUSD?: BigDecimal

	@Required
	@Column("BigInt")
	tickLower: BigInt

	@Required
	@Column("BigInt")
	tickUpper: BigInt

	@Column("BigInt")
	logIndex?: BigInt
  constructor(data: CollectConstructorInput) {super()}
  
  transaction(): Promise<Transaction> {
    return this._transaction
  }

  setTransaction(transaction: Transaction) {
    if (transaction) this.transactionID = transaction.id
  }

  pool(): Promise<Pool> {
    return this._pool
  }

  setPool(pool: Pool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<CollectConstructorInput>): Promise<void> {
    return getStore().update(Collect, values)
  }
}


interface FlashConstructorInput {
  id: ID;
  transactionID?: ID;
  timestamp: BigInt;
  poolID?: ID;
  sender: Bytes;
  recipient: Bytes;
  amount0: BigDecimal;
  amount1: BigDecimal;
  amountUSD: BigDecimal;
  amount0Paid: BigDecimal;
  amount1Paid: BigDecimal;
  logIndex?: BigInt;
}
@Entity("Flash")
export class Flash extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("Transaction")
	_transaction: Promise<Transaction>

	transactionID: ID

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@One("Pool")
	_pool: Promise<Pool>

	poolID: ID

	@Required
	@Column("Bytes")
	sender: Bytes

	@Required
	@Column("Bytes")
	recipient: Bytes

	@Required
	@Column("BigDecimal")
	amount0: BigDecimal

	@Required
	@Column("BigDecimal")
	amount1: BigDecimal

	@Required
	@Column("BigDecimal")
	amountUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	amount0Paid: BigDecimal

	@Required
	@Column("BigDecimal")
	amount1Paid: BigDecimal

	@Column("BigInt")
	logIndex?: BigInt
  constructor(data: FlashConstructorInput) {super()}
  
  transaction(): Promise<Transaction> {
    return this._transaction
  }

  setTransaction(transaction: Transaction) {
    if (transaction) this.transactionID = transaction.id
  }

  pool(): Promise<Pool> {
    return this._pool
  }

  setPool(pool: Pool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<FlashConstructorInput>): Promise<void> {
    return getStore().update(Flash, values)
  }
}


interface UniswapDayDataConstructorInput {
  id: ID;
  date: Int;
  volumeETH: BigDecimal;
  volumeUSD: BigDecimal;
  volumeUSDUntracked: BigDecimal;
  feesUSD: BigDecimal;
  txCount: BigInt;
  tvlUSD: BigDecimal;
}
@Entity("UniswapDayData")
export class UniswapDayData extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	date: Int

	@Required
	@Column("BigDecimal")
	volumeETH: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeUSDUntracked: BigDecimal

	@Required
	@Column("BigDecimal")
	feesUSD: BigDecimal

	@Required
	@Column("BigInt")
	txCount: BigInt

	@Required
	@Column("BigDecimal")
	tvlUSD: BigDecimal
  constructor(data: UniswapDayDataConstructorInput) {super()}
  
  
  static update(values: UpdateValues<UniswapDayDataConstructorInput>): Promise<void> {
    return getStore().update(UniswapDayData, values)
  }
}


interface PoolDayDataConstructorInput {
  id: ID;
  date: Int;
  poolID?: ID;
  liquidity: BigInt;
  sqrtPrice: BigInt;
  token0Price: BigDecimal;
  token1Price: BigDecimal;
  tick?: BigInt;
  tvlUSD: BigDecimal;
  volumeToken0: BigDecimal;
  volumeToken1: BigDecimal;
  volumeUSD: BigDecimal;
  feesUSD: BigDecimal;
  txCount: BigInt;
  open: BigDecimal;
  high: BigDecimal;
  low: BigDecimal;
  close: BigDecimal;
}
@Entity("PoolDayData")
export class PoolDayData extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	date: Int

	@Required
	@One("Pool")
	_pool: Promise<Pool>

	poolID: ID

	@Required
	@Column("BigInt")
	liquidity: BigInt

	@Required
	@Column("BigInt")
	sqrtPrice: BigInt

	@Required
	@Column("BigDecimal")
	token0Price: BigDecimal

	@Required
	@Column("BigDecimal")
	token1Price: BigDecimal

	@Column("BigInt")
	tick?: BigInt

	@Required
	@Column("BigDecimal")
	tvlUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeToken0: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeToken1: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	feesUSD: BigDecimal

	@Required
	@Column("BigInt")
	txCount: BigInt

	@Required
	@Column("BigDecimal")
	open: BigDecimal

	@Required
	@Column("BigDecimal")
	high: BigDecimal

	@Required
	@Column("BigDecimal")
	low: BigDecimal

	@Required
	@Column("BigDecimal")
	close: BigDecimal
  constructor(data: PoolDayDataConstructorInput) {super()}
  
  pool(): Promise<Pool> {
    return this._pool
  }

  setPool(pool: Pool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<PoolDayDataConstructorInput>): Promise<void> {
    return getStore().update(PoolDayData, values)
  }
}


interface PoolHourDataConstructorInput {
  id: ID;
  periodStartUnix: Int;
  poolID?: ID;
  liquidity: BigInt;
  sqrtPrice: BigInt;
  token0Price: BigDecimal;
  token1Price: BigDecimal;
  tick?: BigInt;
  tvlUSD: BigDecimal;
  volumeToken0: BigDecimal;
  volumeToken1: BigDecimal;
  volumeUSD: BigDecimal;
  feesUSD: BigDecimal;
  txCount: BigInt;
  open: BigDecimal;
  high: BigDecimal;
  low: BigDecimal;
  close: BigDecimal;
}
@Entity("PoolHourData")
export class PoolHourData extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	periodStartUnix: Int

	@Required
	@One("Pool")
	_pool: Promise<Pool>

	poolID: ID

	@Required
	@Column("BigInt")
	liquidity: BigInt

	@Required
	@Column("BigInt")
	sqrtPrice: BigInt

	@Required
	@Column("BigDecimal")
	token0Price: BigDecimal

	@Required
	@Column("BigDecimal")
	token1Price: BigDecimal

	@Column("BigInt")
	tick?: BigInt

	@Required
	@Column("BigDecimal")
	tvlUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeToken0: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeToken1: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	feesUSD: BigDecimal

	@Required
	@Column("BigInt")
	txCount: BigInt

	@Required
	@Column("BigDecimal")
	open: BigDecimal

	@Required
	@Column("BigDecimal")
	high: BigDecimal

	@Required
	@Column("BigDecimal")
	low: BigDecimal

	@Required
	@Column("BigDecimal")
	close: BigDecimal
  constructor(data: PoolHourDataConstructorInput) {super()}
  
  pool(): Promise<Pool> {
    return this._pool
  }

  setPool(pool: Pool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<PoolHourDataConstructorInput>): Promise<void> {
    return getStore().update(PoolHourData, values)
  }
}


interface TokenDayDataConstructorInput {
  id: ID;
  date: Int;
  tokenID?: ID;
  volume: BigDecimal;
  volumeUSD: BigDecimal;
  untrackedVolumeUSD: BigDecimal;
  totalValueLocked: BigDecimal;
  totalValueLockedUSD: BigDecimal;
  priceUSD: BigDecimal;
  feesUSD: BigDecimal;
  open: BigDecimal;
  high: BigDecimal;
  low: BigDecimal;
  close: BigDecimal;
}
@Entity("TokenDayData")
export class TokenDayData extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	date: Int

	@Required
	@One("Token")
	_token: Promise<Token>

	tokenID: ID

	@Required
	@Column("BigDecimal")
	volume: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	untrackedVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLocked: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	priceUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	feesUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	open: BigDecimal

	@Required
	@Column("BigDecimal")
	high: BigDecimal

	@Required
	@Column("BigDecimal")
	low: BigDecimal

	@Required
	@Column("BigDecimal")
	close: BigDecimal
  constructor(data: TokenDayDataConstructorInput) {super()}
  
  token(): Promise<Token> {
    return this._token
  }

  setToken(token: Token) {
    if (token) this.tokenID = token.id
  }
  
  static update(values: UpdateValues<TokenDayDataConstructorInput>): Promise<void> {
    return getStore().update(TokenDayData, values)
  }
}


interface TokenHourDataConstructorInput {
  id: ID;
  periodStartUnix: Int;
  tokenID?: ID;
  volume: BigDecimal;
  volumeUSD: BigDecimal;
  untrackedVolumeUSD: BigDecimal;
  totalValueLocked: BigDecimal;
  totalValueLockedUSD: BigDecimal;
  priceUSD: BigDecimal;
  feesUSD: BigDecimal;
  open: BigDecimal;
  high: BigDecimal;
  low: BigDecimal;
  close: BigDecimal;
}
@Entity("TokenHourData")
export class TokenHourData extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("Int")
	periodStartUnix: Int

	@Required
	@One("Token")
	_token: Promise<Token>

	tokenID: ID

	@Required
	@Column("BigDecimal")
	volume: BigDecimal

	@Required
	@Column("BigDecimal")
	volumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	untrackedVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLocked: BigDecimal

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	priceUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	feesUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	open: BigDecimal

	@Required
	@Column("BigDecimal")
	high: BigDecimal

	@Required
	@Column("BigDecimal")
	low: BigDecimal

	@Required
	@Column("BigDecimal")
	close: BigDecimal
  constructor(data: TokenHourDataConstructorInput) {super()}
  
  token(): Promise<Token> {
    return this._token
  }

  setToken(token: Token) {
    if (token) this.tokenID = token.id
  }
  
  static update(values: UpdateValues<TokenHourDataConstructorInput>): Promise<void> {
    return getStore().update(TokenHourData, values)
  }
}


const source = `type Factory @entity {
  # factory address
  id: ID!
  # amount of pools created
  poolCount: BigInt!
  # amoutn of transactions all time
  txCount: BigInt!
  # total volume all time in derived USD
  totalVolumeUSD: BigDecimal!
  # total volume all time in derived ETH
  totalVolumeETH: BigDecimal!
  # total swap fees all time in USD
  totalFeesUSD: BigDecimal!
  # total swap fees all time in USD
  totalFeesETH: BigDecimal!
  # all volume even through less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # TVL derived in USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in ETH
  totalValueLockedETH: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # TVL derived in ETH untracked
  totalValueLockedETHUntracked: BigDecimal!

  # current owner of the factory
  owner: ID!
}

# stores for USD calculations
type Bundle @entity {
  id: ID!
  # price of ETH in usd
  ethPriceUSD: BigDecimal!
}

type Token @entity {
  # token address
  id: Bytes!
  # token symbol
  symbol: String!
  # token name
  name: String!
  # token decimals
  decimals: BigInt!
  # token total supply
  totalSupply: BigInt!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # transactions across all pools that include this token
  txCount: BigInt!
  # number of pools containing this token
  poolCount: BigInt!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # Note: for chains where ETH is not the native token, this will be the derived
  # price of that chain's native token, effectively, this should be renamed
  # derivedNative
  derivedETH: BigDecimal!
  # pools token is in that are white listed for USD pricing
  whitelistPools: [Pool!]!
  # derived fields
  tokenDayData: [TokenDayData!]! @derivedFrom(field: "token")
}

type Pool @entity {
  # pool address
  id: Bytes!
  # creation
  createdAtTimestamp: BigInt!
  # block pool was created at
  createdAtBlockNumber: BigInt!
  # token0
  token0: Token!
  # token1
  token1: Token!
  # fee amount
  feeTier: BigInt!
  # in range liquidity
  liquidity: BigInt!
  # current price tracker
  sqrtPrice: BigInt!
  # token0 per token1
  token0Price: BigDecimal!
  # token1 per token0
  token1Price: BigDecimal!
  # current tick
  tick: BigInt
  # current observation index
  observationIndex: BigInt!
  # all time token0 swapped
  volumeToken0: BigDecimal!
  # all time token1 swapped
  volumeToken1: BigDecimal!
  # all time USD swapped
  volumeUSD: BigDecimal!
  # all time USD swapped, unfiltered for unreliable USD pools
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # all time number of transactions
  txCount: BigInt!
  # all time fees collected token0
  collectedFeesToken0: BigDecimal!
  # all time fees collected token1
  collectedFeesToken1: BigDecimal!
  # all time fees collected derived USD
  collectedFeesUSD: BigDecimal!
  # total token 0 across all ticks
  totalValueLockedToken0: BigDecimal!
  # total token 1 across all ticks
  totalValueLockedToken1: BigDecimal!
  # tvl derived ETH
  totalValueLockedETH: BigDecimal!
  # tvl USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
  # hourly snapshots of pool data
  poolHourData: [PoolHourData!]! @derivedFrom(field: "pool")
  # daily snapshots of pool data
  poolDayData: [PoolDayData!]! @derivedFrom(field: "pool")
  # derived fields
  mints: [Mint!]! @derivedFrom(field: "pool")
  burns: [Burn!]! @derivedFrom(field: "pool")
  swaps: [Swap!]! @derivedFrom(field: "pool")
  collects: [Collect!]! @derivedFrom(field: "pool")
  ticks: [Tick!]! @derivedFrom(field: "pool")
}

type Tick @entity {
  # format: <pool address>#<tick index>
  id: ID!
  # pool address
  poolAddress: Bytes!
  # tick index
  tickIdx: BigInt!
  # pointer to pool
  pool: Pool!
  # total liquidity pool has as tick lower or upper
  liquidityGross: BigInt!
  # how much liquidity changes when tick crossed
  liquidityNet: BigInt!
  # calculated price of token0 of tick within this pool - constant
  price0: BigDecimal!
  # calculated price of token1 of tick within this pool - constant
  price1: BigDecimal!
  # created time
  createdAtTimestamp: BigInt!
  # created block
  createdAtBlockNumber: BigInt!
}

type Transaction @entity {
  # txn hash
  id: ID!
  # block txn was included in
  blockNumber: BigInt!
  # timestamp txn was confirmed
  timestamp: BigInt!
  # gas used during txn execution
  gasUsed: BigInt!
  gasPrice: BigInt!
  # derived values
  mints: [Mint]! @derivedFrom(field: "transaction")
  burns: [Burn]! @derivedFrom(field: "transaction")
  swaps: [Swap]! @derivedFrom(field: "transaction")
  flashed: [Flash]! @derivedFrom(field: "transaction")
  collects: [Collect]! @derivedFrom(field: "transaction")
}

type Mint @entity {
  # transaction hash + "#" + index in mints Transaction array
  id: ID!
  # which txn the mint was included in
  transaction: Transaction!
  # time of txn
  timestamp: BigInt!
  # pool position is within
  pool: Pool!
  # allow indexing by tokens
  token0: Token!
  # allow indexing by tokens
  token1: Token!
  # owner of position where liquidity minted to
  owner: Bytes!
  # the address that minted the liquidity
  sender: Bytes
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # amount of liquidity minted
  amount: BigInt!
  # amount of token 0 minted
  amount0: BigDecimal!
  # amount of token 1 minted
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of the position
  tickLower: BigInt!
  # upper tick of the position
  tickUpper: BigInt!
  # order within the txn
  logIndex: BigInt
}

type Burn @entity {
  # transaction hash + "#" + index in mints Transaction array
  id: ID!
  # txn burn was included in
  transaction: Transaction!
  # pool position is within
  pool: Pool!
  # allow indexing by tokens
  token0: Token!
  # allow indexing by tokens
  token1: Token!
  # need this to pull recent txns for specific token or pool
  timestamp: BigInt!
  # owner of position where liquidity was burned
  owner: Bytes
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # amouny of liquidity burned
  amount: BigInt!
  # amount of token 0 burned
  amount0: BigDecimal!
  # amount of token 1 burned
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of position
  tickLower: BigInt!
  # upper tick of position
  tickUpper: BigInt!
  # position within the transactions
  logIndex: BigInt
}

type Swap @entity {
  # transaction hash + "#" + index in swaps Transaction array
  id: ID!
  # pointer to transaction
  transaction: Transaction!
  # timestamp of transaction
  timestamp: BigInt!
  # pool swap occured within
  pool: Pool!
  # allow indexing by tokens
  token0: Token!
  # allow indexing by tokens
  token1: Token!
  # sender of the swap
  sender: Bytes!
  # recipient of the swap
  recipient: Bytes!
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # delta of token0 swapped
  amount0: BigDecimal!
  # delta of token1 swapped
  amount1: BigDecimal!
  # derived info
  amountUSD: BigDecimal!
  # The sqrt(price) of the pool after the swap, as a Q64.96
  sqrtPriceX96: BigInt!
  # the tick after the swap
  tick: BigInt!
  # index within the txn
  logIndex: BigInt
}

type Collect @entity {
  # transaction hash + "#" + index in collect Transaction array
  id: ID!
  # pointer to txn
  transaction: Transaction!
  # timestamp of event
  timestamp: BigInt!
  # pool collect occured within
  pool: Pool!
  # owner of position collect was performed on
  owner: Bytes
  # amount of token0 collected
  amount0: BigDecimal!
  # amount of token1 collected
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of position
  tickLower: BigInt!
  # uppper tick of position
  tickUpper: BigInt!
  # index within the txn
  logIndex: BigInt
}

type Flash @entity {
  # transaction hash + "-" + index in collect Transaction array
  id: ID!
  # pointer to txn
  transaction: Transaction!
  # timestamp of event
  timestamp: BigInt!
  # pool collect occured within
  pool: Pool!
  # sender of the flash
  sender: Bytes!
  # recipient of the flash
  recipient: Bytes!
  # amount of token0 flashed
  amount0: BigDecimal!
  # amount of token1 flashed
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal!
  # amount token0 paid for flash
  amount0Paid: BigDecimal!
  # amount token1 paid for flash
  amount1Paid: BigDecimal!
  # index within the txn
  logIndex: BigInt
}

# Data accumulated and condensed into day stats for all of Uniswap
type UniswapDayData @entity {
  # timestamp rounded to current day by dividing by 86400
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # total daily volume in Uniswap derived in terms of ETH
  volumeETH: BigDecimal!
  # total daily volume in Uniswap derived in terms of USD
  volumeUSD: BigDecimal!
  # total daily volume in Uniswap derived in terms of USD untracked
  volumeUSDUntracked: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # number of daily transactions
  txCount: BigInt!
  # tvl in terms of USD
  tvlUSD: BigDecimal!
}

# Data accumulated and condensed into day stats for each pool
type PoolDayData @entity {
  # timestamp rounded to current day by dividing by 86400
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # pointer to pool
  pool: Pool!
  # in range liquidity at end of period
  liquidity: BigInt!
  # current price tracker at end of period
  sqrtPrice: BigInt!
  # price of token0 - derived from sqrtPrice
  token0Price: BigDecimal!
  # price of token1 - derived from sqrtPrice
  token1Price: BigDecimal!
  # current tick at end of period
  tick: BigInt
  # tvl derived in USD at end of period
  tvlUSD: BigDecimal!
  # volume in token0
  volumeToken0: BigDecimal!
  # volume in token1
  volumeToken1: BigDecimal!
  # volume in USD
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # numebr of transactions during period
  txCount: BigInt!
  # opening price of token0
  open: BigDecimal!
  # high price of token0
  high: BigDecimal!
  # low price of token0
  low: BigDecimal!
  # close price of token0
  close: BigDecimal!
}

# hourly stats tracker for pool
type PoolHourData @entity {
  # format: <pool address>-<timestamp>
  id: ID!
  # unix timestamp for start of hour
  periodStartUnix: Int!
  # pointer to pool
  pool: Pool!
  # in range liquidity at end of period
  liquidity: BigInt!
  # current price tracker at end of period
  sqrtPrice: BigInt!
  # price of token0 - derived from sqrtPrice
  token0Price: BigDecimal!
  # price of token1 - derived from sqrtPrice
  token1Price: BigDecimal!
  # current tick at end of period
  tick: BigInt
  # tvl derived in USD at end of period
  tvlUSD: BigDecimal!
  # volume in token0
  volumeToken0: BigDecimal!
  # volume in token1
  volumeToken1: BigDecimal!
  # volume in USD
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # numebr of transactions during period
  txCount: BigInt!
  # opening price of token0
  open: BigDecimal!
  # high price of token0
  high: BigDecimal!
  # low price of token0
  low: BigDecimal!
  # close price of token0
  close: BigDecimal!
}

type TokenDayData @entity {
  # token address concatendated with date
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # pointer to token
  token: Token!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # price at end of period in USD
  priceUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # opening price USD
  open: BigDecimal!
  # high price USD
  high: BigDecimal!
  # low price USD
  low: BigDecimal!
  # close price USD
  close: BigDecimal!
}

type TokenHourData @entity {
  # token address concatendated with date
  id: ID!
  # unix timestamp for start of hour
  periodStartUnix: Int!
  # pointer to token
  token: Token!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # price at end of period in USD
  priceUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # opening price USD
  open: BigDecimal!
  # high price USD
  high: BigDecimal!
  # low price USD
  low: BigDecimal!
  # close price USD
  close: BigDecimal!
}

`
DatabaseSchema.register({
  source,
  entities: {
    "Factory": Factory,
		"Bundle": Bundle,
		"Token": Token,
		"Pool": Pool,
		"Tick": Tick,
		"Transaction": Transaction,
		"Mint": Mint,
		"Burn": Burn,
		"Swap": Swap,
		"Collect": Collect,
		"Flash": Flash,
		"UniswapDayData": UniswapDayData,
		"PoolDayData": PoolDayData,
		"PoolHourData": PoolHourData,
		"TokenDayData": TokenDayData,
		"TokenHourData": TokenHourData
  }
})
