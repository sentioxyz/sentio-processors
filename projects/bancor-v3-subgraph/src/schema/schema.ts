
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { String, Int, BigInt, Float, ID, Bytes, Timestamp, Boolean, Int8 } from '@sentio/sdk/store'
import { Entity, Required, One, Many, Column, ListColumn, AbstractEntity, getStore, UpdateValues } from '@sentio/sdk/store'
import { BigDecimal } from '@sentio/bigdecimal'
import { DatabaseSchema } from '@sentio/sdk'

export enum Network {
  ARBITRUM_ONE = "ARBITRUM_ONE", AURORA = "AURORA", AVALANCHE = "AVALANCHE", BSC = "BSC", CELO = "CELO", MAINNET = "MAINNET", FANTOM = "FANTOM", FUSE = "FUSE", MOONBEAM = "MOONBEAM", MOONRIVER = "MOONRIVER", NEAR_MAINNET = "NEAR_MAINNET", OPTIMISM = "OPTIMISM", MATIC = "MATIC", XDAI = "XDAI"
}
export enum ProtocolType {
  EXCHANGE = "EXCHANGE", LENDING = "LENDING", YIELD = "YIELD", BRIDGE = "BRIDGE", GENERIC = "GENERIC"
}
export enum RewardTokenType {
  DEPOSIT = "DEPOSIT", BORROW = "BORROW"
}
export enum LiquidityPoolFeeType {
  FIXED_TRADING_FEE = "FIXED_TRADING_FEE", TIERED_TRADING_FEE = "TIERED_TRADING_FEE", DYNAMIC_TRADING_FEE = "DYNAMIC_TRADING_FEE", FIXED_LP_FEE = "FIXED_LP_FEE", DYNAMIC_LP_FEE = "DYNAMIC_LP_FEE", FIXED_PROTOCOL_FEE = "FIXED_PROTOCOL_FEE", DYNAMIC_PROTOCOL_FEE = "DYNAMIC_PROTOCOL_FEE", DEPOSIT_FEE = "DEPOSIT_FEE", WITHDRAWAL_FEE = "WITHDRAWAL_FEE"
}

export interface Protocol {
  	id: ID
	name: String
	slug: String
	schemaVersion: String
	subgraphVersion: String
	methodologyVersion: String
	network: Network
	type: ProtocolType
	totalValueLockedUSD: BigDecimal
	protocolControlledValueUSD: BigDecimal | undefined
	cumulativeSupplySideRevenueUSD: BigDecimal
	cumulativeProtocolSideRevenueUSD: BigDecimal
	cumulativeTotalRevenueUSD: BigDecimal
	cumulativeUniqueUsers: Int
	totalPoolCount: Int
	dailyUsageMetrics: Array<UsageMetricsDailySnapshot>
	hourlyUsageMetrics: Array<UsageMetricsHourlySnapshot>
	financialMetrics: Array<FinancialsDailySnapshot>
}
export interface Event {
  	id: ID
	hash: String
	logIndex: Int
	protocol: DexAmmProtocol
	to: String
	from: String
	blockNumber: BigInt
	timestamp: BigInt
}



interface TokenConstructorInput {
  id: ID;
  name: String;
  symbol: String;
  decimals: Int;
  lastPriceUSD?: BigDecimal;
  lastPriceBlockNumber?: BigInt;
  _poolTokenID?: ID;
}
@Entity("Token")
export class Token extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("String")
	name: String

	@Required
	@Column("String")
	symbol: String

	@Required
	@Column("Int")
	decimals: Int

	@Column("BigDecimal")
	lastPriceUSD?: BigDecimal

	@Column("BigInt")
	lastPriceBlockNumber?: BigInt

	@One("Token")
	__poolToken: Promise<Token | undefined>

	_poolTokenID: ID
  constructor(data: TokenConstructorInput) {super()}
  
  _poolToken(): Promise<Token | undefined> {
    return this.__poolToken
  }

  set_poolToken(_poolToken: Token | undefined) {
    if (_poolToken) this._poolTokenID = _poolToken.id
  }
  
  static update(values: UpdateValues<TokenConstructorInput>): Promise<void> {
    return getStore().update(Token, values)
  }
}


interface RewardTokenConstructorInput {
  id: ID;
  tokenID?: ID;
  type: RewardTokenType;
}
@Entity("RewardToken")
export class RewardToken extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("Token")
	_token: Promise<Token>

	tokenID: ID

	@Required
	@Column("String")
	type: RewardTokenType
  constructor(data: RewardTokenConstructorInput) {super()}
  
  token(): Promise<Token> {
    return this._token
  }

  setToken(token: Token) {
    if (token) this.tokenID = token.id
  }
  
  static update(values: UpdateValues<RewardTokenConstructorInput>): Promise<void> {
    return getStore().update(RewardToken, values)
  }
}


interface LiquidityPoolFeeConstructorInput {
  id: ID;
  feePercentage?: BigDecimal;
  feeType: LiquidityPoolFeeType;
}
@Entity("LiquidityPoolFee")
export class LiquidityPoolFee extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Column("BigDecimal")
	feePercentage?: BigDecimal

	@Required
	@Column("String")
	feeType: LiquidityPoolFeeType
  constructor(data: LiquidityPoolFeeConstructorInput) {super()}
  
  
  static update(values: UpdateValues<LiquidityPoolFeeConstructorInput>): Promise<void> {
    return getStore().update(LiquidityPoolFee, values)
  }
}


interface DexAmmProtocolConstructorInput {
  id: ID;
  name: String;
  slug: String;
  schemaVersion: String;
  subgraphVersion: String;
  methodologyVersion: String;
  network: Network;
  type: ProtocolType;
  totalValueLockedUSD: BigDecimal;
  protocolControlledValueUSD?: BigDecimal;
  cumulativeVolumeUSD: BigDecimal;
  cumulativeSupplySideRevenueUSD: BigDecimal;
  cumulativeProtocolSideRevenueUSD: BigDecimal;
  cumulativeTotalRevenueUSD: BigDecimal;
  cumulativeUniqueUsers: Int;
  totalPoolCount: Int;
  _poolIDs: Array<ID>;
  _defaultTradingFeeRate: BigDecimal;
  _networkFeeRate: BigDecimal;
  _withdrawalFeeRate: BigDecimal;
}
@Entity("DexAmmProtocol")
export class DexAmmProtocol extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("String")
	name: String

	@Required
	@Column("String")
	slug: String

	@Required
	@Column("String")
	schemaVersion: String

	@Required
	@Column("String")
	subgraphVersion: String

	@Required
	@Column("String")
	methodologyVersion: String

	@Required
	@Column("String")
	network: Network

	@Required
	@Column("String")
	type: ProtocolType

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Column("BigDecimal")
	protocolControlledValueUSD?: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeSupplySideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeProtocolSideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeTotalRevenueUSD: BigDecimal

	@Required
	@Column("Int")
	cumulativeUniqueUsers: Int

	@Required
	@Column("Int")
	totalPoolCount: Int

	@Required
	@ListColumn("ID!")
	_poolIDs: Array<ID>

	@Required
	@Column("BigDecimal")
	_defaultTradingFeeRate: BigDecimal

	@Required
	@Column("BigDecimal")
	_networkFeeRate: BigDecimal

	@Required
	@Column("BigDecimal")
	_withdrawalFeeRate: BigDecimal
  constructor(data: DexAmmProtocolConstructorInput) {super()}
  
  dailyUsageMetrics(): Promise<Array<UsageMetricsDailySnapshot>> {
    return this.store.list(UsageMetricsDailySnapshot, [{field: 'protocol', op: '=', value: this.id}])
  }

  hourlyUsageMetrics(): Promise<Array<UsageMetricsHourlySnapshot>> {
    return this.store.list(UsageMetricsHourlySnapshot, [{field: 'protocol', op: '=', value: this.id}])
  }

  financialMetrics(): Promise<Array<FinancialsDailySnapshot>> {
    return this.store.list(FinancialsDailySnapshot, [{field: 'protocol', op: '=', value: this.id}])
  }

  pools(): Promise<Array<LiquidityPool>> {
    return this.store.list(LiquidityPool, [{field: 'protocol', op: '=', value: this.id}])
  }
  
  static update(values: UpdateValues<DexAmmProtocolConstructorInput>): Promise<void> {
    return getStore().update(DexAmmProtocol, values)
  }
}


interface UsageMetricsDailySnapshotConstructorInput {
  id: ID;
  protocolID?: ID;
  dailyActiveUsers: Int;
  cumulativeUniqueUsers: Int;
  totalPoolCount: Int;
  dailyTransactionCount: Int;
  dailyDepositCount: Int;
  dailyWithdrawCount: Int;
  dailySwapCount: Int;
  blockNumber: BigInt;
  timestamp: BigInt;
}
@Entity("UsageMetricsDailySnapshot")
export class UsageMetricsDailySnapshot extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Required
	@Column("Int")
	dailyActiveUsers: Int

	@Required
	@Column("Int")
	cumulativeUniqueUsers: Int

	@Required
	@Column("Int")
	totalPoolCount: Int

	@Required
	@Column("Int")
	dailyTransactionCount: Int

	@Required
	@Column("Int")
	dailyDepositCount: Int

	@Required
	@Column("Int")
	dailyWithdrawCount: Int

	@Required
	@Column("Int")
	dailySwapCount: Int

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt
  constructor(data: UsageMetricsDailySnapshotConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }
  
  static update(values: UpdateValues<UsageMetricsDailySnapshotConstructorInput>): Promise<void> {
    return getStore().update(UsageMetricsDailySnapshot, values)
  }
}


interface UsageMetricsHourlySnapshotConstructorInput {
  id: ID;
  protocolID?: ID;
  hourlyActiveUsers: Int;
  cumulativeUniqueUsers: Int;
  hourlyTransactionCount: Int;
  hourlyDepositCount: Int;
  hourlyWithdrawCount: Int;
  hourlySwapCount: Int;
  blockNumber: BigInt;
  timestamp: BigInt;
}
@Entity("UsageMetricsHourlySnapshot")
export class UsageMetricsHourlySnapshot extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Required
	@Column("Int")
	hourlyActiveUsers: Int

	@Required
	@Column("Int")
	cumulativeUniqueUsers: Int

	@Required
	@Column("Int")
	hourlyTransactionCount: Int

	@Required
	@Column("Int")
	hourlyDepositCount: Int

	@Required
	@Column("Int")
	hourlyWithdrawCount: Int

	@Required
	@Column("Int")
	hourlySwapCount: Int

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt
  constructor(data: UsageMetricsHourlySnapshotConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }
  
  static update(values: UpdateValues<UsageMetricsHourlySnapshotConstructorInput>): Promise<void> {
    return getStore().update(UsageMetricsHourlySnapshot, values)
  }
}


interface FinancialsDailySnapshotConstructorInput {
  id: ID;
  protocolID?: ID;
  totalValueLockedUSD: BigDecimal;
  protocolControlledValueUSD?: BigDecimal;
  dailyVolumeUSD: BigDecimal;
  cumulativeVolumeUSD: BigDecimal;
  dailySupplySideRevenueUSD: BigDecimal;
  cumulativeSupplySideRevenueUSD: BigDecimal;
  dailyProtocolSideRevenueUSD: BigDecimal;
  cumulativeProtocolSideRevenueUSD: BigDecimal;
  dailyTotalRevenueUSD: BigDecimal;
  cumulativeTotalRevenueUSD: BigDecimal;
  blockNumber: BigInt;
  timestamp: BigInt;
}
@Entity("FinancialsDailySnapshot")
export class FinancialsDailySnapshot extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Column("BigDecimal")
	protocolControlledValueUSD?: BigDecimal

	@Required
	@Column("BigDecimal")
	dailyVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeVolumeUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	dailySupplySideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeSupplySideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	dailyProtocolSideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeProtocolSideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	dailyTotalRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeTotalRevenueUSD: BigDecimal

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt
  constructor(data: FinancialsDailySnapshotConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }
  
  static update(values: UpdateValues<FinancialsDailySnapshotConstructorInput>): Promise<void> {
    return getStore().update(FinancialsDailySnapshot, values)
  }
}


interface LiquidityPoolConstructorInput {
  id: ID;
  protocolID?: ID;
  name?: String;
  symbol?: String;
  inputTokensIDs?: Array<ID>;
  outputTokenID?: ID;
  rewardTokensIDs?: Array<ID>;
  feesIDs?: Array<ID>;
  isSingleSided: Boolean;
  createdTimestamp: BigInt;
  createdBlockNumber: BigInt;
  totalValueLockedUSD: BigDecimal;
  cumulativeSupplySideRevenueUSD: BigDecimal;
  cumulativeProtocolSideRevenueUSD: BigDecimal;
  cumulativeTotalRevenueUSD: BigDecimal;
  cumulativeVolumeUSD: BigDecimal;
  inputTokenBalances: Array<BigInt>;
  inputTokenWeights: Array<BigDecimal>;
  outputTokenSupply?: BigInt;
  outputTokenPriceUSD?: BigDecimal;
  stakedOutputTokenAmount?: BigInt;
  rewardTokenEmissionsAmount?: Array<BigInt>;
  rewardTokenEmissionsUSD?: Array<BigDecimal>;
  _tradingFeeRate: BigDecimal;
  _cumulativeTradingFeeAmountUSD: BigDecimal;
  _cumulativeWithdrawalFeeAmountUSD: BigDecimal;
  _latestRewardProgramID: BigInt;
}
@Entity("LiquidityPool")
export class LiquidityPool extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Column("String")
	name?: String

	@Column("String")
	symbol?: String

	@Required
	@Many("Token!")
	_inputTokens: Promise<Array<Token>>

	inputTokensIDs: Array<ID | undefined>

	@One("Token")
	_outputToken: Promise<Token | undefined>

	outputTokenID: ID

	@Many("RewardToken!")
	_rewardTokens: Promise<Array<RewardToken>>

	rewardTokensIDs: Array<ID | undefined>

	@Required
	@Many("LiquidityPoolFee!")
	_fees: Promise<Array<LiquidityPoolFee>>

	feesIDs: Array<ID | undefined>

	@Required
	@Column("Boolean")
	isSingleSided: Boolean

	@Required
	@Column("BigInt")
	createdTimestamp: BigInt

	@Required
	@Column("BigInt")
	createdBlockNumber: BigInt

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeSupplySideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeProtocolSideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeTotalRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeVolumeUSD: BigDecimal

	@Required
	@ListColumn("BigInt!")
	inputTokenBalances: Array<BigInt>

	@Required
	@ListColumn("BigDecimal!")
	inputTokenWeights: Array<BigDecimal>

	@Column("BigInt")
	outputTokenSupply?: BigInt

	@Column("BigDecimal")
	outputTokenPriceUSD?: BigDecimal

	@Column("BigInt")
	stakedOutputTokenAmount?: BigInt

	@ListColumn("BigInt!")
	rewardTokenEmissionsAmount?: Array<BigInt>

	@ListColumn("BigDecimal!")
	rewardTokenEmissionsUSD?: Array<BigDecimal>

	@Required
	@Column("BigDecimal")
	_tradingFeeRate: BigDecimal

	@Required
	@Column("BigDecimal")
	_cumulativeTradingFeeAmountUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	_cumulativeWithdrawalFeeAmountUSD: BigDecimal

	@Required
	@Column("BigInt")
	_latestRewardProgramID: BigInt
  constructor(data: LiquidityPoolConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }

  inputTokens(): Promise<Array<Token>> {
    return this._inputTokens
  }

  setInputTokens(inputTokens: Array<Token>) {
    if (inputTokens) this.inputTokensIDs = inputTokens.map((e) => e.id)
  }

  outputToken(): Promise<Token | undefined> {
    return this._outputToken
  }

  setOutputToken(outputToken: Token | undefined) {
    if (outputToken) this.outputTokenID = outputToken.id
  }

  rewardTokens(): Promise<Array<RewardToken>> {
    return this._rewardTokens
  }

  setRewardTokens(rewardTokens: Array<RewardToken>) {
    if (rewardTokens) this.rewardTokensIDs = rewardTokens.map((e) => e.id)
  }

  fees(): Promise<Array<LiquidityPoolFee>> {
    return this._fees
  }

  setFees(fees: Array<LiquidityPoolFee>) {
    if (fees) this.feesIDs = fees.map((e) => e.id)
  }

  dailySnapshots(): Promise<Array<LiquidityPoolDailySnapshot>> {
    return this.store.list(LiquidityPoolDailySnapshot, [{field: 'pool', op: '=', value: this.id}])
  }

  hourlySnapshots(): Promise<Array<LiquidityPoolHourlySnapshot>> {
    return this.store.list(LiquidityPoolHourlySnapshot, [{field: 'pool', op: '=', value: this.id}])
  }

  deposits(): Promise<Array<Deposit>> {
    return this.store.list(Deposit, [{field: 'pool', op: '=', value: this.id}])
  }

  withdraws(): Promise<Array<Withdraw>> {
    return this.store.list(Withdraw, [{field: 'pool', op: '=', value: this.id}])
  }

  swaps(): Promise<Array<Swap>> {
    return this.store.list(Swap, [{field: 'pool', op: '=', value: this.id}])
  }
  
  static update(values: UpdateValues<LiquidityPoolConstructorInput>): Promise<void> {
    return getStore().update(LiquidityPool, values)
  }
}


interface LiquidityPoolDailySnapshotConstructorInput {
  id: ID;
  protocolID?: ID;
  poolID?: ID;
  blockNumber: BigInt;
  timestamp: BigInt;
  totalValueLockedUSD: BigDecimal;
  cumulativeSupplySideRevenueUSD: BigDecimal;
  dailySupplySideRevenueUSD: BigDecimal;
  cumulativeProtocolSideRevenueUSD: BigDecimal;
  dailyProtocolSideRevenueUSD: BigDecimal;
  cumulativeTotalRevenueUSD: BigDecimal;
  dailyTotalRevenueUSD: BigDecimal;
  dailyVolumeUSD: BigDecimal;
  dailyVolumeByTokenAmount: Array<BigInt>;
  dailyVolumeByTokenUSD: Array<BigDecimal>;
  cumulativeVolumeUSD: BigDecimal;
  inputTokenBalances: Array<BigInt>;
  inputTokenWeights: Array<BigDecimal>;
  outputTokenSupply?: BigInt;
  outputTokenPriceUSD?: BigDecimal;
  stakedOutputTokenAmount?: BigInt;
  rewardTokenEmissionsAmount?: Array<BigInt>;
  rewardTokenEmissionsUSD?: Array<BigDecimal>;
}
@Entity("LiquidityPoolDailySnapshot")
export class LiquidityPoolDailySnapshot extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Required
	@One("LiquidityPool")
	_pool: Promise<LiquidityPool>

	poolID: ID

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeSupplySideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	dailySupplySideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeProtocolSideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	dailyProtocolSideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeTotalRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	dailyTotalRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	dailyVolumeUSD: BigDecimal

	@Required
	@ListColumn("BigInt!")
	dailyVolumeByTokenAmount: Array<BigInt>

	@Required
	@ListColumn("BigDecimal!")
	dailyVolumeByTokenUSD: Array<BigDecimal>

	@Required
	@Column("BigDecimal")
	cumulativeVolumeUSD: BigDecimal

	@Required
	@ListColumn("BigInt!")
	inputTokenBalances: Array<BigInt>

	@Required
	@ListColumn("BigDecimal!")
	inputTokenWeights: Array<BigDecimal>

	@Column("BigInt")
	outputTokenSupply?: BigInt

	@Column("BigDecimal")
	outputTokenPriceUSD?: BigDecimal

	@Column("BigInt")
	stakedOutputTokenAmount?: BigInt

	@ListColumn("BigInt!")
	rewardTokenEmissionsAmount?: Array<BigInt>

	@ListColumn("BigDecimal!")
	rewardTokenEmissionsUSD?: Array<BigDecimal>
  constructor(data: LiquidityPoolDailySnapshotConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }

  pool(): Promise<LiquidityPool> {
    return this._pool
  }

  setPool(pool: LiquidityPool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<LiquidityPoolDailySnapshotConstructorInput>): Promise<void> {
    return getStore().update(LiquidityPoolDailySnapshot, values)
  }
}


interface LiquidityPoolHourlySnapshotConstructorInput {
  id: ID;
  protocolID?: ID;
  poolID?: ID;
  blockNumber: BigInt;
  timestamp: BigInt;
  totalValueLockedUSD: BigDecimal;
  cumulativeSupplySideRevenueUSD: BigDecimal;
  hourlySupplySideRevenueUSD: BigDecimal;
  cumulativeProtocolSideRevenueUSD: BigDecimal;
  hourlyProtocolSideRevenueUSD: BigDecimal;
  cumulativeTotalRevenueUSD: BigDecimal;
  hourlyTotalRevenueUSD: BigDecimal;
  hourlyVolumeUSD: BigDecimal;
  hourlyVolumeByTokenAmount: Array<BigInt>;
  hourlyVolumeByTokenUSD: Array<BigDecimal>;
  cumulativeVolumeUSD: BigDecimal;
  inputTokenBalances: Array<BigInt>;
  inputTokenWeights: Array<BigDecimal>;
  outputTokenSupply?: BigInt;
  outputTokenPriceUSD?: BigDecimal;
  stakedOutputTokenAmount?: BigInt;
  rewardTokenEmissionsAmount?: Array<BigInt>;
  rewardTokenEmissionsUSD?: Array<BigDecimal>;
}
@Entity("LiquidityPoolHourlySnapshot")
export class LiquidityPoolHourlySnapshot extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Required
	@One("LiquidityPool")
	_pool: Promise<LiquidityPool>

	poolID: ID

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@Column("BigDecimal")
	totalValueLockedUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeSupplySideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	hourlySupplySideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeProtocolSideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	hourlyProtocolSideRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	cumulativeTotalRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	hourlyTotalRevenueUSD: BigDecimal

	@Required
	@Column("BigDecimal")
	hourlyVolumeUSD: BigDecimal

	@Required
	@ListColumn("BigInt!")
	hourlyVolumeByTokenAmount: Array<BigInt>

	@Required
	@ListColumn("BigDecimal!")
	hourlyVolumeByTokenUSD: Array<BigDecimal>

	@Required
	@Column("BigDecimal")
	cumulativeVolumeUSD: BigDecimal

	@Required
	@ListColumn("BigInt!")
	inputTokenBalances: Array<BigInt>

	@Required
	@ListColumn("BigDecimal!")
	inputTokenWeights: Array<BigDecimal>

	@Column("BigInt")
	outputTokenSupply?: BigInt

	@Column("BigDecimal")
	outputTokenPriceUSD?: BigDecimal

	@Column("BigInt")
	stakedOutputTokenAmount?: BigInt

	@ListColumn("BigInt!")
	rewardTokenEmissionsAmount?: Array<BigInt>

	@ListColumn("BigDecimal!")
	rewardTokenEmissionsUSD?: Array<BigDecimal>
  constructor(data: LiquidityPoolHourlySnapshotConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }

  pool(): Promise<LiquidityPool> {
    return this._pool
  }

  setPool(pool: LiquidityPool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<LiquidityPoolHourlySnapshotConstructorInput>): Promise<void> {
    return getStore().update(LiquidityPoolHourlySnapshot, values)
  }
}


interface DepositConstructorInput {
  id: ID;
  hash: String;
  logIndex: Int;
  protocolID?: ID;
  to: String;
  from: String;
  blockNumber: BigInt;
  timestamp: BigInt;
  inputTokensIDs?: Array<ID>;
  outputTokenID?: ID;
  inputTokenAmounts: Array<BigInt>;
  outputTokenAmount?: BigInt;
  amountUSD: BigDecimal;
  poolID?: ID;
}
@Entity("Deposit")
export class Deposit extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("String")
	hash: String

	@Required
	@Column("Int")
	logIndex: Int

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Required
	@Column("String")
	to: String

	@Required
	@Column("String")
	from: String

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@Many("Token!")
	_inputTokens: Promise<Array<Token>>

	inputTokensIDs: Array<ID | undefined>

	@One("Token")
	_outputToken: Promise<Token | undefined>

	outputTokenID: ID

	@Required
	@ListColumn("BigInt!")
	inputTokenAmounts: Array<BigInt>

	@Column("BigInt")
	outputTokenAmount?: BigInt

	@Required
	@Column("BigDecimal")
	amountUSD: BigDecimal

	@Required
	@One("LiquidityPool")
	_pool: Promise<LiquidityPool>

	poolID: ID
  constructor(data: DepositConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }

  inputTokens(): Promise<Array<Token>> {
    return this._inputTokens
  }

  setInputTokens(inputTokens: Array<Token>) {
    if (inputTokens) this.inputTokensIDs = inputTokens.map((e) => e.id)
  }

  outputToken(): Promise<Token | undefined> {
    return this._outputToken
  }

  setOutputToken(outputToken: Token | undefined) {
    if (outputToken) this.outputTokenID = outputToken.id
  }

  pool(): Promise<LiquidityPool> {
    return this._pool
  }

  setPool(pool: LiquidityPool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<DepositConstructorInput>): Promise<void> {
    return getStore().update(Deposit, values)
  }
}


interface WithdrawConstructorInput {
  id: ID;
  hash: String;
  logIndex: Int;
  protocolID?: ID;
  to: String;
  from: String;
  blockNumber: BigInt;
  timestamp: BigInt;
  inputTokensIDs?: Array<ID>;
  outputTokenID?: ID;
  inputTokenAmounts: Array<BigInt>;
  outputTokenAmount?: BigInt;
  amountUSD: BigDecimal;
  poolID?: ID;
  _withdrawalFeeAmount: BigInt;
  _withdrawalFeeAmountUSD: BigDecimal;
}
@Entity("Withdraw")
export class Withdraw extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("String")
	hash: String

	@Required
	@Column("Int")
	logIndex: Int

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Required
	@Column("String")
	to: String

	@Required
	@Column("String")
	from: String

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@Many("Token!")
	_inputTokens: Promise<Array<Token>>

	inputTokensIDs: Array<ID | undefined>

	@One("Token")
	_outputToken: Promise<Token | undefined>

	outputTokenID: ID

	@Required
	@ListColumn("BigInt!")
	inputTokenAmounts: Array<BigInt>

	@Column("BigInt")
	outputTokenAmount?: BigInt

	@Required
	@Column("BigDecimal")
	amountUSD: BigDecimal

	@Required
	@One("LiquidityPool")
	_pool: Promise<LiquidityPool>

	poolID: ID

	@Required
	@Column("BigInt")
	_withdrawalFeeAmount: BigInt

	@Required
	@Column("BigDecimal")
	_withdrawalFeeAmountUSD: BigDecimal
  constructor(data: WithdrawConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }

  inputTokens(): Promise<Array<Token>> {
    return this._inputTokens
  }

  setInputTokens(inputTokens: Array<Token>) {
    if (inputTokens) this.inputTokensIDs = inputTokens.map((e) => e.id)
  }

  outputToken(): Promise<Token | undefined> {
    return this._outputToken
  }

  setOutputToken(outputToken: Token | undefined) {
    if (outputToken) this.outputTokenID = outputToken.id
  }

  pool(): Promise<LiquidityPool> {
    return this._pool
  }

  setPool(pool: LiquidityPool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<WithdrawConstructorInput>): Promise<void> {
    return getStore().update(Withdraw, values)
  }
}


interface SwapConstructorInput {
  id: ID;
  hash: String;
  logIndex: Int;
  protocolID?: ID;
  to: String;
  from: String;
  blockNumber: BigInt;
  timestamp: BigInt;
  tokenInID?: ID;
  amountIn: BigInt;
  amountInUSD: BigDecimal;
  tokenOutID?: ID;
  amountOut: BigInt;
  amountOutUSD: BigDecimal;
  poolID?: ID;
  _tradingFeeAmount: BigInt;
  _tradingFeeAmountUSD: BigDecimal;
}
@Entity("Swap")
export class Swap extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@Column("String")
	hash: String

	@Required
	@Column("Int")
	logIndex: Int

	@Required
	@One("DexAmmProtocol")
	_protocol: Promise<DexAmmProtocol>

	protocolID: ID

	@Required
	@Column("String")
	to: String

	@Required
	@Column("String")
	from: String

	@Required
	@Column("BigInt")
	blockNumber: BigInt

	@Required
	@Column("BigInt")
	timestamp: BigInt

	@Required
	@One("Token")
	_tokenIn: Promise<Token>

	tokenInID: ID

	@Required
	@Column("BigInt")
	amountIn: BigInt

	@Required
	@Column("BigDecimal")
	amountInUSD: BigDecimal

	@Required
	@One("Token")
	_tokenOut: Promise<Token>

	tokenOutID: ID

	@Required
	@Column("BigInt")
	amountOut: BigInt

	@Required
	@Column("BigDecimal")
	amountOutUSD: BigDecimal

	@Required
	@One("LiquidityPool")
	_pool: Promise<LiquidityPool>

	poolID: ID

	@Required
	@Column("BigInt")
	_tradingFeeAmount: BigInt

	@Required
	@Column("BigDecimal")
	_tradingFeeAmountUSD: BigDecimal
  constructor(data: SwapConstructorInput) {super()}
  
  protocol(): Promise<DexAmmProtocol> {
    return this._protocol
  }

  setProtocol(protocol: DexAmmProtocol) {
    if (protocol) this.protocolID = protocol.id
  }

  tokenIn(): Promise<Token> {
    return this._tokenIn
  }

  setTokenIn(tokenIn: Token) {
    if (tokenIn) this.tokenInID = tokenIn.id
  }

  tokenOut(): Promise<Token> {
    return this._tokenOut
  }

  setTokenOut(tokenOut: Token) {
    if (tokenOut) this.tokenOutID = tokenOut.id
  }

  pool(): Promise<LiquidityPool> {
    return this._pool
  }

  setPool(pool: LiquidityPool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<SwapConstructorInput>): Promise<void> {
    return getStore().update(Swap, values)
  }
}


interface AccountConstructorInput {
  id: ID;
}
@Entity("Account")
export class Account extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID
  constructor(data: AccountConstructorInput) {super()}
  
  
  static update(values: UpdateValues<AccountConstructorInput>): Promise<void> {
    return getStore().update(Account, values)
  }
}


interface ActiveAccountConstructorInput {
  id: ID;
}
@Entity("ActiveAccount")
export class ActiveAccount extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID
  constructor(data: ActiveAccountConstructorInput) {super()}
  
  
  static update(values: UpdateValues<ActiveAccountConstructorInput>): Promise<void> {
    return getStore().update(ActiveAccount, values)
  }
}


interface RewardProgramConstructorInput {
  id: ID;
  poolID?: ID;
  enabled: Boolean;
  totalRewards: BigInt;
  startTime: BigInt;
  endTime: BigInt;
  rewardsRate: BigInt;
}
@Entity("RewardProgram")
export class RewardProgram extends AbstractEntity  {

	@Required
	@Column("ID")
	id: ID

	@Required
	@One("LiquidityPool")
	_pool: Promise<LiquidityPool>

	poolID: ID

	@Required
	@Column("Boolean")
	enabled: Boolean

	@Required
	@Column("BigInt")
	totalRewards: BigInt

	@Required
	@Column("BigInt")
	startTime: BigInt

	@Required
	@Column("BigInt")
	endTime: BigInt

	@Required
	@Column("BigInt")
	rewardsRate: BigInt
  constructor(data: RewardProgramConstructorInput) {super()}
  
  pool(): Promise<LiquidityPool> {
    return this._pool
  }

  setPool(pool: LiquidityPool) {
    if (pool) this.poolID = pool.id
  }
  
  static update(values: UpdateValues<RewardProgramConstructorInput>): Promise<void> {
    return getStore().update(RewardProgram, values)
  }
}


const source = `# Subgraph Schema: DEX AMM
# Version: 1.3.0
# See https://github.com/messari/subgraphs/blob/master/docs/SCHEMA.md for details

enum Network {
  ARBITRUM_ONE
  AURORA
  AVALANCHE
  BSC # aka BNB Chain
  CELO
  MAINNET # Ethereum Mainnet
  FANTOM
  FUSE
  MOONBEAM
  MOONRIVER
  NEAR_MAINNET
  OPTIMISM
  MATIC # aka Polygon
  XDAI # aka Gnosis Chain
}

enum ProtocolType {
  EXCHANGE
  LENDING
  YIELD
  BRIDGE
  GENERIC
  # Will add more
}

type Token @entity  {
  " Smart contract address of the token "
  id: ID!

  " Name of the token, mirrored from the smart contract "
  name: String!

  " Symbol of the token, mirrored from the smart contract "
  symbol: String!

  " The number of decimal places this token uses, default to 18 "
  decimals: Int!

  " Optional field to track the price of a token, mostly for caching purposes "
  lastPriceUSD: BigDecimal

  " Optional field to track the block number of the last token price "
  lastPriceBlockNumber: BigInt

  _poolToken: Token
}

enum RewardTokenType {
  " For reward tokens awarded to LPs/lenders "
  DEPOSIT

  " For reward tokens awarded to borrowers "
  BORROW
}

type RewardToken @entity  {
  " { Reward token type }-{ Smart contract address of the reward token } "
  id: ID!

  " Reference to the actual token "
  token: Token!

  " The type of the reward token "
  type: RewardTokenType!
}

# Note that trading fee is the fee paid *by* the users, whereas LP fee and
# protocol fee are fees paid *to* the corresponding parties.
# Most of the time, trading fee = liquidity provider fee + protocol fee,
# but not always. Thus we explicitly specify all different fee types.
enum LiquidityPoolFeeType {
  " Total fixed fee paid by the user per trade, as a percentage of the traded amount. e.g. 0.3% for Uniswap v2, 0.3% for Sushiswap, 0.04% for Curve v1. "
  FIXED_TRADING_FEE

  " Some protocols use tiered fees instead of fixed fee (e.g. DYDX, DODO). Set 'feePercentage' as 0 but handle the tiered fees in the mapping code. "
  TIERED_TRADING_FEE

  " Some protocols use dynamic fees instead of fixed fee (e.g. Balancer v2). Set 'feePercentage' as 0 but handle the dynamic fees in the mapping code. "
  DYNAMIC_TRADING_FEE

  " Fixed fee that's paid to the LP, as a percentage of the traded amount. e.g. 0.25% for Sushiswap, 0.02% for Curve v1. "
  FIXED_LP_FEE

  " Some protocols use dynamic LP fees (e.g., Bancor v2). Set 'feePercentage' as 0 but handle the dynamic fees in the mapping code. "
  DYNAMIC_LP_FEE

  " Fixed fee that's paid to the protocol, as a percentage of the traded amount. e.g. 0.05% for Sushiswap, 0.02% for Curve v1. "
  FIXED_PROTOCOL_FEE

  " Some protocols use dynamic protocol fees (e.g., Bancor v2). Set 'feePercentage' as 0 but handle the dynamic fees in the mapping code. "
  DYNAMIC_PROTOCOL_FEE

  " One-time fee charged by the protocol during deposit, in percentages of the deposit token "
  DEPOSIT_FEE

  " One-time fee charged by the protocol (e.g. Bancor v3) during withdrawal, in percentages of the withdrawal token "
  WITHDRAWAL_FEE
}

type LiquidityPoolFee @entity  {
  " { Fee type }-{ Pool address } "
  id: ID!

  " Fee as a percentage of the trade (swap) amount. Does not always apply "
  feePercentage: BigDecimal

  " Type of fee this pool uses "
  feeType: LiquidityPoolFeeType!
}

#############################
##### Protocol Metadata #####
#############################

interface Protocol {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: ID!

  " Name of the protocol, including version. e.g. Uniswap v3 "
  name: String!

  " Slug of protocol, including version. e.g. uniswap-v3 "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " The blockchain network this subgraph is indexing on "
  network: Network!

  " The type of protocol (e.g. DEX, Lending, Yield, etc) "
  type: ProtocolType!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " # of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Total number of pools "
  totalPoolCount: Int!

  ##### Snapshots #####

  " Daily usage metrics for this protocol "
  dailyUsageMetrics: [UsageMetricsDailySnapshot!]!
    @derivedFrom(field: "protocol")

  " Hourly usage metrics for this protocol "
  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]!
    @derivedFrom(field: "protocol")

  " Daily financial metrics for this protocol "
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")
}

type DexAmmProtocol  @entity  {
  " Smart contract address of the protocol's main contract (Factory, Registry, etc) "
  id: ID!

  " Name of the protocol, including version. e.g. Uniswap v3 "
  name: String!

  " Slug of protocol, including version. e.g. uniswap-v3 "
  slug: String!

  " Version of the subgraph schema, in SemVer format (e.g. 1.0.0) "
  schemaVersion: String!

  " Version of the subgraph implementation, in SemVer format (e.g. 1.0.0) "
  subgraphVersion: String!

  " Version of the methodology used to compute metrics, loosely based on SemVer format (e.g. 1.0.0) "
  methodologyVersion: String!

  " The blockchain network this subgraph is indexing on "
  network: Network!

  " The type of protocol (e.g. DEX, Lending, Yield, etc) "
  type: ProtocolType!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " All historical volume in USD "
  cumulativeVolumeUSD: BigDecimal!

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " # of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Total number of pools "
  totalPoolCount: Int!

  ##### Snapshots #####

  " Daily usage metrics for this protocol "
  dailyUsageMetrics: [UsageMetricsDailySnapshot!]!
    @derivedFrom(field: "protocol")

  " Hourly usage metrics for this protocol "
  hourlyUsageMetrics: [UsageMetricsHourlySnapshot!]!
    @derivedFrom(field: "protocol")

  " Daily financial metrics for this protocol "
  financialMetrics: [FinancialsDailySnapshot!]! @derivedFrom(field: "protocol")

  ##### Pools #####

  " All pools that belong to this protocol "
  pools: [LiquidityPool!]! @derivedFrom(field: "protocol")

  " Liquidity pool IDs "
  _poolIDs: [ID!]!

  " Default trading fee rate (0-1) that applies at the protocol level "
  _defaultTradingFeeRate: BigDecimal!

  " Netfork fee rate (0-1) that applies at the protocol level. It goes to protocol fee "
  _networkFeeRate: BigDecimal!

  " Withdrawal fee rate (0-1) that applies at the protocol level. Occurs whenver user withdraws. It goes to protocol fee "
  _withdrawalFeeRate: BigDecimal!
}

###############################
##### Protocol Timeseries #####
###############################

type UsageMetricsDailySnapshot @entity  {
  " ID is # of days since Unix epoch time "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: DexAmmProtocol!

  " # of unique daily active users "
  dailyActiveUsers: Int!

  " # of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Total number of pools "
  totalPoolCount: Int!

  " Total number of transactions occurred in a day. Transactions include all entities that implement the Event interface. "
  dailyTransactionCount: Int!

  " Total number of deposits (add liquidity) in a day "
  dailyDepositCount: Int!

  " Total number of withdrawals (remove liquidity) in a day "
  dailyWithdrawCount: Int!

  " Total number of trades (swaps) in a day "
  dailySwapCount: Int!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

type UsageMetricsHourlySnapshot @entity  {
  " { # of hours since Unix epoch time } "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: DexAmmProtocol!

  " # of unique hourly active users "
  hourlyActiveUsers: Int!

  " # of cumulative unique users "
  cumulativeUniqueUsers: Int!

  " Total number of transactions occurred in an hour. Transactions include all entities that implement the Event interface. "
  hourlyTransactionCount: Int!

  " Total number of deposits (add liquidity) in an hour "
  hourlyDepositCount: Int!

  " Total number of withdrawals (remove liquidity) in an hour "
  hourlyWithdrawCount: Int!

  " Total number of trades (swaps) in an hour "
  hourlySwapCount: Int!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

type FinancialsDailySnapshot @entity  {
  " ID is # of days since Unix epoch time "
  id: ID!

  " Protocol this snapshot is associated with "
  protocol: DexAmmProtocol!

  " Current TVL (Total Value Locked) of the entire protocol "
  totalValueLockedUSD: BigDecimal!

  " Current PCV (Protocol Controlled Value). Only relevant for protocols with PCV. "
  protocolControlledValueUSD: BigDecimal

  " All trade volume occurred in a given day, in USD "
  dailyVolumeUSD: BigDecimal!

  " All historical trade volume in USD "
  cumulativeVolumeUSD: BigDecimal!

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  dailySupplySideRevenueUSD: BigDecimal!

  " Revenue claimed by suppliers to the protocol. LPs on DEXs (e.g. 0.25% of the swap fee in Sushiswap). Depositors on Lending Protocols. NFT sellers on OpenSea. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  dailyProtocolSideRevenueUSD: BigDecimal!

  " Gross revenue for the protocol (revenue claimed by protocol). Examples: AMM protocol fee (Sushi’s 0.05%). OpenSea 10% sell fee. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  dailyTotalRevenueUSD: BigDecimal!

  " All revenue generated by the protocol. e.g. 0.30% of swap fee in Sushiswap, all yield generated by Yearn. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!
}

###############################
##### Pool-Level Metadata #####
###############################

type LiquidityPool @entity  {
  " Smart contract address of the pool "
  id: ID!

  " The protocol this pool belongs to "
  protocol: DexAmmProtocol!

  " Name of liquidity pool (e.g. Curve.fi DAI/USDC/USDT) "
  name: String

  " Symbol of liquidity pool (e.g. 3CRV) "
  symbol: String

  " Tokens that need to be deposited to take a position in protocol. e.g. WETH and USDC to deposit into the WETH-USDC pool. Array to account for multi-asset pools like Curve and Balancer "
  inputTokens: [Token!]!

  " Token that is minted to track ownership of position in protocol "
  outputToken: Token

  " Aditional tokens that are given as reward for position in a protocol, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon, usually in liquidity mining programs. e.g. SUSHI in the Onsen program, MATIC for Aave Polygon "
  rewardTokens: [RewardToken!]

  " Fees per trade incurred to the user. Should include all fees that apply to a pool (e.g. Curve has a trading fee AND an admin fee, which is a portion of the trading fee. Uniswap only has a trading fee and no protocol fee. ) "
  fees: [LiquidityPoolFee!]!

  " Whether this pool is single-sided (e.g. Bancor, Platypus's Alternative Pool). The specifics of the implementation depends on the protocol. "
  isSingleSided: Boolean!

  " Creation timestamp "
  createdTimestamp: BigInt!

  " Creation block number "
  createdBlockNumber: BigInt!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of this pool in USD "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the liquidity pool, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the liquidity pool, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the liquidity pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " All historical trade volume occurred in this pool, in USD "
  cumulativeVolumeUSD: BigDecimal!

  " Amount of input tokens in the pool. The ordering should be the same as the pool's 'inputTokens' field. "
  inputTokenBalances: [BigInt!]!

  " Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool "
  inputTokenWeights: [BigDecimal!]!

  " Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]

  ##### Snapshots #####

  " Liquidity pool daily snapshots "
  dailySnapshots: [LiquidityPoolDailySnapshot!]! @derivedFrom(field: "pool")

  " Liquidity pool hourly snapshots "
  hourlySnapshots: [LiquidityPoolHourlySnapshot!]! @derivedFrom(field: "pool")

  ##### Events #####

  " All deposit (add liquidity) events occurred in this pool "
  deposits: [Deposit!]! @derivedFrom(field: "pool")

  " All withdraw (remove liquidity) events occurred in this pool "
  withdraws: [Withdraw!]! @derivedFrom(field: "pool")

  " All trade (swap) events occurred in this pool "
  swaps: [Swap!]! @derivedFrom(field: "pool")

  " Trading fee rate (0-1) that applies at pool level "
  _tradingFeeRate: BigDecimal!

  " Cumulative trading fee in USD "
  _cumulativeTradingFeeAmountUSD: BigDecimal!

  " Cumulative withdrawal fee in USD "
  _cumulativeWithdrawalFeeAmountUSD: BigDecimal!

  " The latest reward program. It matches latestProgramId from the StandardRewards contract "
  _latestRewardProgramID: BigInt!
}

#################################
##### Pool-Level Timeseries #####
#################################

type LiquidityPoolDailySnapshot @entity  {
  " { Smart contract address of the pool }-{ # of days since Unix epoch time } "
  id: ID!

  " The protocol this snapshot belongs to "
  protocol: DexAmmProtocol!

  " The pool this snapshot belongs to "
  pool: LiquidityPool!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of this pool "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the liquidity pool, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Daily revenue generated by the liquidity pool, accrued to the supply side. "
  dailySupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the liquidity pool, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Daily revenue generated by the liquidity pool, accrued to the protocol. "
  dailyProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the liquidity pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Daily revenue generated by the liquidity pool. "
  dailyTotalRevenueUSD: BigDecimal!

  " All trade volume occurred in a given day, in USD "
  dailyVolumeUSD: BigDecimal!

  " All trade volume occurred in a given day for a specific input token, in native amount. The ordering should be the same as the pool's 'inputTokens' field. "
  dailyVolumeByTokenAmount: [BigInt!]!

  " All trade volume occurred in a given day for a specific input token, in USD. The ordering should be the same as the pool's 'inputTokens' field. "
  dailyVolumeByTokenUSD: [BigDecimal!]!

  " All historical trade volume occurred in this pool, in USD "
  cumulativeVolumeUSD: BigDecimal!

  " Amount of input tokens in the pool. The ordering should be the same as the pool's 'inputTokens' field. "
  inputTokenBalances: [BigInt!]!

  " Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool "
  inputTokenWeights: [BigDecimal!]!

  " Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day, in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day, in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]
}

type LiquidityPoolHourlySnapshot @entity  {
  " { Smart contract address of the pool }-{ # of hours since Unix epoch time } "
  id: ID!

  " The protocol this snapshot belongs to "
  protocol: DexAmmProtocol!

  " The pool this snapshot belongs to "
  pool: LiquidityPool!

  " Block number of this snapshot "
  blockNumber: BigInt!

  " Timestamp of this snapshot "
  timestamp: BigInt!

  ##### Quantitative Data #####

  " Current TVL (Total Value Locked) of this pool "
  totalValueLockedUSD: BigDecimal!

  " All revenue generated by the liquidity pool, accrued to the supply side. "
  cumulativeSupplySideRevenueUSD: BigDecimal!

  " Hourly revenue generated by the liquidity pool, accrued to the supply side. "
  hourlySupplySideRevenueUSD: BigDecimal!

  " All revenue generated by the liquidity pool, accrued to the protocol. "
  cumulativeProtocolSideRevenueUSD: BigDecimal!

  " Hourly revenue generated by the liquidity pool, accrued to the protocol. "
  hourlyProtocolSideRevenueUSD: BigDecimal!

  " All revenue generated by the liquidity pool. "
  cumulativeTotalRevenueUSD: BigDecimal!

  " Hourly revenue generated by the liquidity pool. "
  hourlyTotalRevenueUSD: BigDecimal!

  " All trade volume occurred in a given hour, in USD "
  hourlyVolumeUSD: BigDecimal!

  " All trade volume occurred in a given hour for a specific input token, in native amount. The ordering should be the same as the pool's 'inputTokens' field. "
  hourlyVolumeByTokenAmount: [BigInt!]!

  " All trade volume occurred in a given hour for a specific input token, in USD. The ordering should be the same as the pool's 'inputTokens' field. "
  hourlyVolumeByTokenUSD: [BigDecimal!]!

  " All historical trade volume occurred in this pool, in USD "
  cumulativeVolumeUSD: BigDecimal!

  " Amount of input tokens in the pool. The ordering should be the same as the pool's 'inputTokens' field. "
  inputTokenBalances: [BigInt!]!

  " Weights of input tokens in the liquidity pool in percentage values. For example, 50/50 for Uniswap pools, 48.2/51.8 for a Curve pool, 10/10/80 for a Balancer pool "
  inputTokenWeights: [BigDecimal!]!

  " Total supply of output token. Note that certain DEXes don't have an output token (e.g. Bancor) "
  outputTokenSupply: BigInt

  " Price per share of output token in USD "
  outputTokenPriceUSD: BigDecimal

  " Total supply of output tokens that are staked (usually in the MasterChef contract). Used to calculate reward APY. "
  stakedOutputTokenAmount: BigInt

  " Per-block reward token emission as of the current block normalized to a day (not hour), in token's native amount. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsAmount: [BigInt!]

  " Per-block reward token emission as of the current block normalized to a day (not hour), in USD value. This should be ideally calculated as the theoretical rate instead of the realized amount. "
  rewardTokenEmissionsUSD: [BigDecimal!]
}

##################################
##### Transaction-Level Data #####
##################################

"""
An event is any user action that occurs in a protocol. Generally, they are Ethereum events
emitted by a function in the smart contracts, stored in transaction receipts as event logs.
However, some user actions of interest are function calls that don't emit events. For example,
the deposit and withdraw functions in Yearn do not emit any events. In our subgraphs, we still
store them as events, although they are not technically Ethereum events emitted by smart
contracts.
"""
interface Event {
  " { Event type }-{ Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: DexAmmProtocol!

  " Address that received the tokens "
  to: String!

  " Address that sent the tokens "
  from: String!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!
}

type Deposit  @entity  {
  " deposit-{ Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: DexAmmProtocol!

  " Address that received the tokens "
  to: String!

  " Address that sent the tokens "
  from: String!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!

  " Input tokens of the pool. E.g. WETH and USDC to a WETH-USDC pool "
  inputTokens: [Token!]!

  " Output token of the pool. E.g. the UNI-LP token "
  outputToken: Token

  " Amount of input tokens in the token's native unit "
  inputTokenAmounts: [BigInt!]!

  " Amount of output tokens in the token's native unit "
  outputTokenAmount: BigInt

  " USD-normalized value of the transaction of the underlying (e.g. sum of tokens deposited into a pool) "
  amountUSD: BigDecimal!

  " The pool involving this transaction "
  pool: LiquidityPool!
}

type Withdraw  @entity  {
  " withdraw-{ Transaction hash }-{ Log index }"
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: DexAmmProtocol!

  " Address that received the tokens "
  to: String!

  " Address that sent the tokens "
  from: String!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!

  " Input tokens of the pool (not input tokens of the event/transaction). E.g. WETH and USDC from a WETH-USDC pool "
  inputTokens: [Token!]!

  " Output token of the pool (not output token of the event/transaction). E.g. the UNI-LP token "
  outputToken: Token

  " Amount of input tokens in the token's native unit "
  inputTokenAmounts: [BigInt!]!

  " Amount of output tokens in the token's native unit "
  outputTokenAmount: BigInt

  " USD-normalized value of the transaction of the underlying (e.g. sum of tokens withdrawn from a pool) "
  amountUSD: BigDecimal!

  " The pool involving this transaction "
  pool: LiquidityPool!

  _withdrawalFeeAmount: BigInt!
  _withdrawalFeeAmountUSD: BigDecimal!
}

type Swap  @entity  {
  " swap-{ Transaction hash }-{ Log index } "
  id: ID!

  " Transaction hash of the transaction that emitted this event "
  hash: String!

  " Event log index. For transactions that don't emit event, create arbitrary index starting from 0 "
  logIndex: Int!

  " The protocol this transaction belongs to "
  protocol: DexAmmProtocol!

  " Address that received the tokens "
  to: String!

  " Address that sent the tokens "
  from: String!

  " Block number of this event "
  blockNumber: BigInt!

  " Timestamp of this event "
  timestamp: BigInt!

  " Token deposited into pool "
  tokenIn: Token!

  " Amount of token deposited into pool in native units "
  amountIn: BigInt!

  " Amount of token deposited into pool in USD "
  amountInUSD: BigDecimal!

  " Token withdrawn from pool "
  tokenOut: Token!

  " Amount of token withdrawn from pool in native units "
  amountOut: BigInt!

  " Amount of token withdrawn from pool in USD "
  amountOutUSD: BigDecimal!

  " The pool involving this transaction "
  pool: LiquidityPool!

  _tradingFeeAmount: BigInt!
  _tradingFeeAmountUSD: BigDecimal!
}

# An account is a unique Ethereum address
# Helps to accumulate total unique users
type Account @entity  {
  " Address of the account "
  id: ID!
}

# Helper entity for calculating daily/hourly active users
type ActiveAccount @entity {
  " { daily/hourly }-{ Address of the account }-{ Days/hours since Unix epoch } "
  id: ID!
}

# Helper entity to store info about Bancor V3 reward program
type RewardProgram @entity {
  id: ID!
  pool: LiquidityPool!
  enabled: Boolean!
  totalRewards: BigInt!
  startTime: BigInt!
  endTime: BigInt!
  rewardsRate: BigInt!
}


`
DatabaseSchema.register({
  source,
  entities: {
    "Token": Token,
		"RewardToken": RewardToken,
		"LiquidityPoolFee": LiquidityPoolFee,
		"DexAmmProtocol": DexAmmProtocol,
		"UsageMetricsDailySnapshot": UsageMetricsDailySnapshot,
		"UsageMetricsHourlySnapshot": UsageMetricsHourlySnapshot,
		"FinancialsDailySnapshot": FinancialsDailySnapshot,
		"LiquidityPool": LiquidityPool,
		"LiquidityPoolDailySnapshot": LiquidityPoolDailySnapshot,
		"LiquidityPoolHourlySnapshot": LiquidityPoolHourlySnapshot,
		"Deposit": Deposit,
		"Withdraw": Withdraw,
		"Swap": Swap,
		"Account": Account,
		"ActiveAccount": ActiveAccount,
		"RewardProgram": RewardProgram
  }
})
